<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wildfire Sim | Smoke & Fire</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #a1c4fd; 
            font-family: 'Segoe UI', sans-serif; 
        }
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.7); backdrop-filter: blur(12px);
            color: #2c3e50; padding: 20px; border-radius: 12px; width: 280px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15); z-index: 10;
        }
        h3 { margin: 0 0 15px 0; font-size: 18px; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 10px; }
        .control { margin-bottom: 18px; }
        label { display: flex; justify-content: space-between; font-size: 10px; color: #555; font-weight: 800; text-transform: uppercase; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #e67e22; }
        button { 
            background: #2c3e50; color: white; border: none; padding: 10px; 
            width: 100%; cursor: pointer; border-radius: 6px; font-weight: bold; 
        }
        #toolbar {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; background: rgba(255,255,255,0.8); padding: 12px 25px;
            border-radius: 50px; backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .tool {
            width: 55px; height: 55px; border-radius: 50%; background: white; 
            cursor: pointer; font-size: 26px; display: flex; align-items: center; 
            justify-content: center; transition: 0.3s;
        }
        .tool.active { border: 2px solid #e67e22; transform: scale(1.1); }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #f0f4f8; display: flex; justify-content: center; align-items: center;
            font-size: 20px; z-index: 999;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="loading">Atmospheric Processing...</div>

<div id="ui">
    <h3>Terrain Analysis</h3>
    <div class="control">
        <label>Time Speed <span id="simSpeedVal">1.0x</span></label>
        <input type="range" id="simSpeed" min="0.1" max="5.0" step="0.1" value="1.0">
    </div>
    <div class="control">
        <label>Wind Heading <span id="windDirVal">0Â°</span></label>
        <input type="range" id="windDir" min="0" max="360" value="0">
    </div>
    <div class="control">
        <label>Wind Velocity <span id="windSpeedVal">25</span></label>
        <input type="range" id="windSpeed" min="0" max="80" value="25">
    </div>
    <button id="resetBtn">Regenerate Grid</button>
</div>

<div id="toolbar">
    <div class="tool active" id="toolIgnite">ðŸ”¥</div>
    <div class="tool" id="toolCut">ðŸª“</div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- CONFIG ---
    const CONFIG = { count: 100000, worldSize: 1500, cellSize: 20, smokeCount: 15000 };
    const S_LIVE = 0, S_DRYING = 1, S_BURNING = 2, S_CHARRED = 3, S_CUT = 4;
    const FUEL_PROPS = {
        0: { spread: 2.5, burn: 0.4, scaleY: 0.3, scaleXZ: 0.6, col: 0x95a23e }, 
        1: { spread: 1.0, burn: 1.0, scaleY: 0.8, scaleXZ: 1.0, col: 0x6b8e23 }, 
        2: { spread: 0.4, burn: 3.5, scaleY: 1.8, scaleXZ: 1.2, col: 0x2d4c1e }  
    };

    let simSpeed = 1.0, windVec = { x: 0, z: -1 }, windSpeed = 25, currentTool = 'ignite';

    // --- SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa1c4fd);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 5, 6000);
    camera.position.set(0, 1400, 1200);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85));

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x4f4f2f, 0.9));
    const sun = new THREE.DirectionalLight(0xfff5e1, 1.2);
    sun.position.set(400, 700, 300);
    scene.add(sun);

    // --- SMOKE SYSTEM ---
    const smokeGeo = new THREE.BufferAttribute(new Float32Array(CONFIG.smokeCount * 3), 3);
    const smokeSizes = new THREE.BufferAttribute(new Float32Array(CONFIG.smokeCount), 1);
    const smokePointsGeo = new THREE.BufferGeometry();
    smokePointsGeo.setAttribute('position', smokeGeo);
    smokePointsGeo.setAttribute('size', smokeSizes);
    
    const smokeMat = new THREE.PointsMaterial({
        color: 0x333333,
        size: 15,
        transparent: true,
        opacity: 0.4,
        blending: THREE.NormalBlending,
        sizeAttenuation: true
    });
    const smokeParticles = new THREE.Points(smokePointsGeo, smokeMat);
    scene.add(smokeParticles);

    const smokeData = new Float32Array(CONFIG.smokeCount * 4); // x, y, z, life
    let smokeIndex = 0;

    // --- TERRAIN & TREES ---
    const groundGeo = new THREE.PlaneGeometry(1800, 1800, 100, 100);
    const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x5a7a44, roughness: 0.8 }));
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    const treeGeo = new THREE.CylinderGeometry(0, 1.8, 7, 4);
    treeGeo.translate(0, 3.5, 0);
    const mesh = new THREE.InstancedMesh(treeGeo, new THREE.MeshStandardMaterial({ flatShading: true }), CONFIG.count);
    scene.add(mesh);

    let data = new Float32Array(CONFIG.count * 8); // x, z, state, moisture, fuel_remaining, ?, y, type
    const spatialMap = [];
    const mapDim = 77, mapOffset = 750;

    function init() {
        document.getElementById('loading').style.display = 'flex';
        setTimeout(() => {
            for(let i=0; i<mapDim*mapDim; i++) spatialMap[i] = [];
            for(let i=0; i<CONFIG.count; i++) {
                const idx = i * 8;
                const x = (Math.random()-0.5) * CONFIG.worldSize;
                const z = (Math.random()-0.5) * CONFIG.worldSize;
                const type = Math.floor(Math.random()*3);
                const props = FUEL_PROPS[type];
                
                data[idx] = x; data[idx+1] = z; data[idx+2] = S_LIVE; data[idx+3] = 150;
                data[idx+4] = props.burn * 2000; data[idx+6] = 0; data[idx+7] = type;

                const mat = new THREE.Matrix4().makeTranslation(x, 0, z);
                mat.scale(new THREE.Vector3(props.scaleXZ, props.scaleY, props.scaleXZ));
                mesh.setMatrixAt(i, mat);
                mesh.setColorAt(i, new THREE.Color(props.col));
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;
            document.getElementById('loading').style.display = 'none';
        }, 100);
    }

    function spawnSmoke(x, y, z) {
        const idx = smokeIndex * 4;
        smokeData[idx] = x; smokeData[idx+1] = y; smokeData[idx+2] = z; smokeData[idx+3] = 1.0;
        smokeIndex = (smokeIndex + 1) % CONFIG.smokeCount;
    }

    function updatePhysics() {
        let needColor = false, needMatrix = false;
        const burningIndices = [];

        for(let i=0; i<CONFIG.count; i++) {
            const idx = i * 8;
            if(data[idx+2] === S_BURNING) {
                burningIndices.push(i);
                data[idx+4] -= simSpeed;
                
                // Spawn smoke particles
                if(Math.random() < 0.05 * simSpeed) spawnSmoke(data[idx], 10, data[idx+1]);

                if(data[idx+4] <= 0) {
                    data[idx+2] = S_CHARRED;
                    mesh.setColorAt(i, new THREE.Color(0x111111));
                    needColor = true;
                } else if(Math.random() > 0.8) {
                    const flicker = 1.5 + Math.random() * 2;
                    mesh.setColorAt(i, new THREE.Color().setRGB(flicker, flicker*0.4, 0));
                    needColor = true;
                }
            }
        }

        // Simple Spread Logic (Direct Proximity)
        if(burningIndices.length > 0 && Math.random() > 0.5) {
            const b = burningIndices[Math.floor(Math.random()*burningIndices.length)];
            const bx = data[b*8], bz = data[b*8+1];
            for(let j=0; j<20; j++) {
                const target = Math.floor(Math.random()*CONFIG.count);
                if(data[target*8+2] < S_BURNING) {
                    const dx = data[target*8]-bx, dz = data[target*8+1]-bz;
                    if(dx*dx + dz*dz < 400) { 
                        data[target*8+2] = S_BURNING; 
                        mesh.setColorAt(target, new THREE.Color(2, 0.5, 0));
                        needColor = true;
                    }
                }
            }
        }

        // Update Smoke Particles
        const posAttr = smokePointsGeo.attributes.position;
        for(let i=0; i<CONFIG.smokeCount; i++) {
            const idx = i * 4;
            if(smokeData[idx+3] > 0) {
                smokeData[idx] += windVec.x * (windSpeed/20) * simSpeed;
                smokeData[idx+1] += 2 * simSpeed; // Rise
                smokeData[idx+2] += windVec.z * (windSpeed/20) * simSpeed;
                smokeData[idx+3] -= 0.01 * simSpeed; // Fade
                posAttr.setXYZ(i, smokeData[idx], smokeData[idx+1], smokeData[idx+2]);
            } else {
                posAttr.setXYZ(i, 0, -1000, 0); // Hide
            }
        }
        posAttr.needsUpdate = true;

        if(needColor) mesh.instanceColor.needsUpdate = true;
    }

    // --- INPUTS ---
    const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    window.addEventListener('mousedown', (e) => {
        mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(ground);
        if(hits.length > 0) {
            const pt = hits[0].point;
            for(let i=0; i<CONFIG.count; i++) {
                if(Math.pow(data[i*8]-pt.x,2) + Math.pow(data[i*8+1]-pt.z,2) < 400) {
                    if(currentTool === 'ignite') data[i*8+2] = S_BURNING;
                    else { data[i*8+2] = S_CUT; mesh.setMatrixAt(i, new THREE.Matrix4().makeScale(0,0,0)); }
                }
            }
            mesh.instanceMatrix.needsUpdate = true;
        }
    });

    function updateUI() {
        simSpeed = parseFloat(document.getElementById('simSpeed').value);
        const d = parseInt(document.getElementById('windDir').value);
        windSpeed = parseInt(document.getElementById('windSpeed').value);
        windVec.x = Math.sin(d * Math.PI/180); windVec.z = -Math.cos(d * Math.PI/180);
        document.getElementById('simSpeedVal').innerText = simSpeed.toFixed(1) + 'x';
        document.getElementById('windDirVal').innerText = d + 'Â°';
        document.getElementById('windSpeedVal').innerText = windSpeed;
    }

    document.getElementById('simSpeed').addEventListener('input', updateUI);
    document.getElementById('windDir').addEventListener('input', updateUI);
    document.getElementById('windSpeed').addEventListener('input', updateUI);
    document.getElementById('resetBtn').addEventListener('click', init);
    document.getElementById('toolIgnite').addEventListener('click', () => { currentTool='ignite'; document.getElementById('toolIgnite').classList.add('active'); document.getElementById('toolCut').classList.remove('active'); });
    document.getElementById('toolCut').addEventListener('click', () => { currentTool='cut'; document.getElementById('toolCut').classList.add('active'); document.getElementById('toolIgnite').classList.remove('active'); });

    init();
    function animate() {
        requestAnimationFrame(animate);
        updatePhysics();
        controls.update();
        composer.render();
    }
    animate();
</script>
</body>
</html>
