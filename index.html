<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wildfire Lab: 24hr Cycle & Veering Winds</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.9); color: #333;
            padding: 15px; border-radius: 8px; border: 1px solid #ccc;
            width: 290px; user-select: none; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            max-height: 90vh; overflow-y: auto; z-index: 10;
        }
        #clock-display {
            font-size: 24px; font-weight: 800; text-align: center; 
            margin-bottom: 10px; font-family: 'Courier New', monospace;
            color: #d32f2f; background: #222; padding: 5px; border-radius: 4px;
        }
        h3 { margin: 0 0 10px 0; color: #222; font-weight: 600; border-bottom: 2px solid #ddd; padding-bottom: 8px; }
        .control { margin-bottom: 12px; }
        label { display: flex; justify-content: space-between; font-size: 11px; color: #666; font-weight: bold; margin-bottom: 4px;}
        input[type=range] { width: 100%; cursor: pointer; accent-color: #d32f2f; }
        button { background: #f0f0f0; border: 1px solid #ccc; padding: 8px; width: 100%; cursor: pointer; border-radius: 4px; font-weight: bold; margin-top: 5px; }
        .val { color: #d32f2f; font-weight: 700; }
        .weather-toggle { display: flex; gap: 5px; margin-top: 5px; }
        .w-btn { flex: 1; padding: 8px; border: 1px solid #ccc; background: white; cursor: pointer; border-radius: 4px; font-size: 14px; }
        .w-btn.active { background: #d32f2f; color: white; border-color: #b71c1c; }
        #toolbar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: rgba(255,255,255,0.9); padding: 12px 20px;
            border-radius: 50px; box-shadow: 0 5px 20px rgba(0,0,0,0.4);
        }
        .tool {
            width: 45px; height: 45px; border-radius: 50%; border: 2px solid #eee;
            background: white; cursor: pointer; font-size: 20px; display: flex;
            align-items: center; justify-content: center; transition: 0.15s;
        }
        .tool.active { border-color: #d32f2f; background: #fff0f0; transform: scale(1.15); }
        #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #eef0f5; display: flex; justify-content: center; align-items: center; font-size: 24px; z-index: 999; }
    </style>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>
</head>
<body>
<div id="loading">Syncing Atmospheric Data...</div>
<div id="ui">
    <div id="clock-display">12:00</div>
    <h3>Environmental Control</h3>
    <div class="control">
        <label>Weather Condition</label>
        <div class="weather-toggle">
            <button class="w-btn active" id="w-sunny" title="Sunny">‚òÄÔ∏è</button>
            <button class="w-btn" id="w-cloudy" title="Cloudy">‚òÅÔ∏è</button>
            <button class="w-btn" id="w-rain" title="Rain">üåßÔ∏è</button>
        </div>
    </div>
    <div class="control"><label>Simulation Speed <span id="simSpeedVal" class="val">1.0x</span></label><input type="range" id="simSpeed" min="0.1" max="5.0" step="0.1" value="1.0"></div>
    <div class="control"><label>Wind Base Speed <span id="windSpeedVal" class="val">25</span></label><input type="range" id="windSpeed" min="0" max="80" value="25"></div>
    <div id="wind-info" style="font-size: 10px; color: #888; font-style: italic;">Wind is backing/veering with time...</div>
    <button id="resetBtn">Reset Map</button>
</div>
<div id="toolbar">
    <div class="tool active" id="toolIgnite" title="Ignite">üî•</div>
    <div class="tool" id="toolCut" title="Firebreak">ü™ì</div>
    <div class="tool" id="toolSculpt" title="Sculpt">‚õ∞Ô∏è</div>
    <div class="tool" id="toolWater" title="Water">üíß</div>
    <div class="tool" id="toolRoad" title="Track">üõ£Ô∏è</div>
</div>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const CONFIG = { count: 80000, worldSize: 1500, cellSize: 22, baseSpreadRate: 0.05, dryingRate: 0.07 };
    const S_LIVE = 0, S_DRYING = 1, S_BURNING = 2, S_CHARRED = 3, S_CUT = 4;
    const F_GRASS = 0, F_BRUSH = 1, F_TIMBER = 2;
    const FUEL_PROPS = {
        [F_GRASS]: { spread: 2.5, burn: 0.4, scaleY: 0.3, scaleXZ: 0.6, col: 0x7cfc00 },
        [F_BRUSH]: { spread: 1.0, burn: 1.0, scaleY: 0.8, scaleXZ: 1.0, col: 0x556b2f },
        [F_TIMBER]: { spread: 0.4, burn: 3.5, scaleY: 1.8, scaleXZ: 1.2, col: 0x004d00 }
    };

    let currentTool = 'ignite', simSpeed = 1.0, isShift = false, isDragging = false, weather = 'sunny';
    let simTime = 12 * 60; // Minutes from midnight
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 5, 6000);
    camera.position.set(0, 1600, 1300);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // --- LIGHTING ---
    const sun = new THREE.DirectionalLight(0xffffff, 1.2); scene.add(sun);
    const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); scene.add(ambient);

    // --- RAIN ---
    const rainCount = 10000;
    const rainGeo = new THREE.BufferGeometry();
    const rainPos = new Float32Array(rainCount * 3);
    for(let i=0; i<rainCount*3; i+=3) { 
        rainPos[i] = (Math.random()-0.5)*2000; rainPos[i+1] = Math.random()*1000; rainPos[i+2] = (Math.random()-0.5)*2000; 
    }
    rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
    const rainSystem = new THREE.Points(rainGeo, new THREE.PointsMaterial({ color: 0xaaaaaa, size: 2, transparent: true, opacity: 0.6 }));
    rainSystem.visible = false; scene.add(rainSystem);

    const groundGeo = new THREE.PlaneGeometry(1800, 1800, 100, 100);
    const groundMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9 });
    const ground = new THREE.Mesh(groundGeo, groundMat); ground.rotation.x = -Math.PI / 2; scene.add(ground);

    const data = new Float32Array(CONFIG.count * 8); 
    let spatialMap = [], mapDim = Math.ceil(CONFIG.worldSize / CONFIG.cellSize) + 2, mapOffset = CONFIG.worldSize / 2;
    const mesh = new THREE.InstancedMesh(new THREE.CylinderGeometry(0, 1.8, 7, 4).translate(0, 3.5, 0), new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true }), CONFIG.count);
    scene.add(mesh);

    const raycaster = new THREE.Raycaster();
    const _mat = new THREE.Matrix4(), _pos = new THREE.Vector3(), _scale = new THREE.Vector3(), _quat = new THREE.Quaternion();

    function getElevation(x, z) {
        raycaster.set(new THREE.Vector3(x, 2000, z), new THREE.Vector3(0, -1, 0));
        const hit = raycaster.intersectObject(ground); return hit.length > 0 ? hit[0].point.y : 0;
    }

    function init(reset = false) {
        document.getElementById('loading').style.display = 'flex';
        const pos = groundGeo.attributes.position, col = new THREE.BufferAttribute(new Float32Array(pos.count * 3), 3);
        groundGeo.setAttribute('color', col);
        for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i), z = pos.getY(i);
            pos.setZ(i, reset ? 0 : (Math.sin(x*0.005)*30 + Math.cos(z*0.004)*30));
            col.setXYZ(i, 0.36, 0.42, 0.27);
        }
        pos.needsUpdate = true; groundGeo.computeVertexNormals();
        spatialMap = new Array(mapDim*mapDim).fill(0).map(()=>[]);
        setTimeout(() => {
            for(let i=0; i<CONFIG.count; i++) {
                const idx = i * 8, x = (Math.random()-0.5) * CONFIG.worldSize, z = (Math.random()-0.5) * CONFIG.worldSize;
                const n = Math.sin(x*0.003) + Math.cos(z*0.003), type = n > 0.8 ? F_TIMBER : (n < -0.5 ? F_GRASS : F_BRUSH);
                const props = FUEL_PROPS[type], y = getElevation(x, z);
                data[idx] = x; data[idx+1] = z; data[idx+2] = S_LIVE; data[idx+3] = 150; data[idx+4] = 3000 * props.burn; data[idx+6] = y; data[idx+7] = type;
                _pos.set(x, y, z); _scale.set(props.scaleXZ, props.scaleY, props.scaleXZ); _quat.setFromAxisAngle(new THREE.Vector3(0,1,0), Math.random()*6.28);
                _mat.compose(_pos, _quat, _scale); mesh.setMatrixAt(i, _mat); mesh.setColorAt(i, new THREE.Color(props.col));
            }
            mesh.instanceMatrix.needsUpdate = true; mesh.instanceColor.needsUpdate = true;
            document.getElementById('loading').style.display = 'none';
        }, 100);
    }

    function updateTimeAndWind() {
        simTime = (simTime + 0.1 * simSpeed) % 1440;
        const hrs = Math.floor(simTime / 60), mins = Math.floor(simTime % 60);
        document.getElementById('clock-display').innerText = `${hrs.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}`;

        // Cycle: Noon (1), Sunset (0), Midnight (-1), Sunrise (0)
        const dayProgress = (simTime - 720) / 720; 
        const lightAngle = dayProgress * Math.PI;
        sun.position.set(Math.cos(lightAngle)*400, Math.sin(lightAngle)*700, 300);
        
        const dayFactor = Math.max(0, Math.sin(lightAngle));
        sun.intensity = dayFactor * (weather === 'sunny' ? 1.5 : (weather === 'cloudy' ? 0.6 : 0.2));
        ambient.intensity = Math.max(0.1, dayFactor * 0.6);
        scene.background.lerpColors(new THREE.Color(0x020205), (weather==='sunny'?new THREE.Color(0x87ceeb):new THREE.Color(0x445566)), Math.max(0.05, dayFactor));

        // Backing and Veering Wind (Sinusoidal shift of angle over time)
        const windBaseAngle = Math.sin(simTime * 0.005) * 0.5; // Oscillates angle
        windDir = windBaseAngle;
    }

    let windDir = 0, wSpeed = 25;

    function paint(ox, oz, colHex, hMod, feat) {
        const pos = groundGeo.attributes.position, col = groundGeo.attributes.color, r = 60, c = new THREE.Color(colHex);
        for (let i = 0; i < pos.count; i++) {
            const dx = pos.getX(i) - ox, dz = -pos.getY(i) - oz, dSq = dx*dx + dz*dz;
            if (dSq < r*r) {
                const inf = 1 - Math.sqrt(dSq)/r;
                if (hMod !== 0) pos.setZ(i, pos.getZ(i) + hMod * inf);
                if (feat) col.setXYZ(i, c.r, c.g, c.b);
            }
        }
        pos.needsUpdate = true; col.needsUpdate = true; groundGeo.computeVertexNormals();
        updateTrees(ox, oz, r + 50, feat);
    }

    function updateTrees(ox, oz, r, kill) {
        const rSq = r*r;
        for(let i=0; i<CONFIG.count; i++) {
            const idx = i*8;
            if (Math.pow(data[idx]-ox, 2) + Math.pow(data[idx+1]-oz, 2) < rSq) {
                const y = getElevation(data[idx], data[idx+1]); data[idx+6] = y;
                mesh.getMatrixAt(i, _mat); _mat.decompose(_pos, _quat, _scale);
                if (kill && y < -2) { _scale.set(0,0,0); data[idx+2] = S_CUT; } else { _pos.y = y; }
                _mat.compose(_pos, _quat, _scale); mesh.setMatrixAt(i, _mat);
            }
        }
        mesh.instanceMatrix.needsUpdate = true;
    }

    function handleInput(e) {
        mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse, camera); const hit = raycaster.intersectObject(ground);
        if(!hit.length) return; const pt = hit[0].point;
        if(currentTool==='ignite') ignite(pt.x, pt.z);
        else if(currentTool==='cut') cut(pt.x, pt.z);
        else if(currentTool==='sculpt') paint(pt.x, pt.z, 0, isShift?-5:5, false);
        else if(currentTool==='water') paint(pt.x, pt.z, 0x4da6ff, -3, true);
        else if(currentTool==='road') paint(pt.x, pt.z, 0x777777, 0.2, true);
    }

    function ignite(ox, oz) {
        let best = -1, dMin = 900;
        for(let i=0; i<CONFIG.count; i++) {
            const dSq = Math.pow(data[i*8]-ox, 2) + Math.pow(data[i*8+1]-oz, 2);
            if(dSq < dMin) { dMin = dSq; best = i; }
        }
        if(best!==-1) { data[best*8+2] = S_BURNING; data[best*8+3] = 0; }
    }

    function cut(ox, oz) {
        for(let i=0; i<CONFIG.count; i++) {
            if(Math.pow(data[i*8]-ox, 2) + Math.pow(data[i*8+1]-oz, 2) < 225) {
                data[i*8+2] = S_CUT; _mat.makeScale(0,0,0); mesh.setMatrixAt(i, _mat);
            }
        }
        mesh.instanceMatrix.needsUpdate = true;
    }

    window.addEventListener('keydown', e => isShift = e.shiftKey); window.addEventListener('keyup', e => isShift = e.shiftKey);
    window.addEventListener('mousedown', e => { if(e.target.tagName==='CANVAS') isDragging = true; handleInput(e); });
    window.addEventListener('mousemove', e => { if(isDragging) handleInput(e); }); window.addEventListener('mouseup', () => isDragging = false);

    ['ignite', 'cut', 'sculpt', 'water', 'road'].forEach(t => document.getElementById('tool'+t.charAt(0).toUpperCase()+t.slice(1)).onclick = () => {
        currentTool = t; document.querySelectorAll('.tool').forEach(x => x.classList.remove('active'));
        document.getElementById('tool'+t.charAt(0).toUpperCase()+t.slice(1)).classList.add('active');
    });

    ['sunny', 'cloudy', 'rain'].forEach(w => document.getElementById('w-'+w).onclick = () => {
        weather = w; document.querySelectorAll('.w-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('w-'+w).classList.add('active');
        rainSystem.visible = (w==='rain');
    });
    document.getElementById('resetBtn').onclick = () => init(true);
    document.getElementById('simSpeed').oninput = e => { simSpeed = e.target.value; document.getElementById('simSpeedVal').innerText = simSpeed+'x'; };
    document.getElementById('windSpeed').oninput = e => { wSpeed = e.target.value; document.getElementById('windSpeedVal').innerText = wSpeed; };
    init();

    (function animate() {
        requestAnimationFrame(animate);
        updateTimeAndWind();
        if(weather === 'rain') {
            const pos = rainGeo.attributes.position.array;
            for(let i=1; i<pos.length; i+=3) { pos[i]-=15; if(pos[i]<0) pos[i]=1000; }
            rainGeo.attributes.position.needsUpdate = true;
        }
        for(let i=0; i<spatialMap.length; i++) spatialMap[i].length = 0;
        for(let i=0; i<CONFIG.count; i++) {
            if(data[i*8+2] === S_BURNING) {
                const gx = Math.floor((data[i*8]+mapOffset)/CONFIG.cellSize), gz = Math.floor((data[i*8+1]+mapOffset)/CONFIG.cellSize);
                if(gx>=0 && gx<mapDim && gz>=0 && gz<mapDim) spatialMap[gz*mapDim+gx].push(i);
            }
        }
        for(let i=0; i<CONFIG.count; i++) {
            const idx = i*8, state = data[idx+2]; if(state === S_CHARRED || state === S_CUT) continue;
            if(state === S_BURNING) {
                data[idx+4] -= simSpeed * (weather === 'rain' ? 2.5 : 1.0);
                if(data[idx+4] <= 0) {
                    data[idx+2] = S_CHARRED; mesh.setColorAt(i, new THREE.Color(0x111111));
                    mesh.getMatrixAt(i, _mat); _mat.decompose(_pos, _quat, _scale); _scale.y = 0.1; _mat.compose(_pos, _quat, _scale); mesh.setMatrixAt(i, _mat);
                }
                continue;
            }
            if(weather === 'rain' && data[idx+3] < 150) data[idx+3] += 1.0 * simSpeed;
            
            const gx = Math.floor((data[idx]+mapOffset)/CONFIG.cellSize), gz = Math.floor((data[idx+1]+mapOffset)/CONFIG.cellSize);
            let heat = 0;
            for(let nz=gz-1; nz<=gz+1; nz++) for(let nx=gx-1; nx<=gx+1; nx++) {
                if(nx>=0 && nx<mapDim && nz>=0 && nz<mapDim) spatialMap[nz*mapDim+nx].forEach(fIdx => {
                    const dx = data[idx]-data[fIdx*8], dz = data[idx+1]-data[fIdx*8+1], dSq = dx*dx+dz*dz;
                    if(dSq < 900) {
                        const dist = Math.sqrt(dSq);
                        const wx = Math.sin(windDir), wz = -Math.cos(windDir);
                        const dot = (dx/dist)*wx + (dz/dist)*wz;
                        const slope = (data[idx+6]-data[fIdx*8+6])/(dist+0.1);
                        heat += (1-dist/30) * (dot>0?1+dot*wSpeed*0.15:1+dot*0.8) * (slope>0?1+slope*6:1+slope) * FUEL_PROPS[data[fIdx*8+7]].spread;
                    }
                });
            }
            if(heat > 0) {
                const dryingMod = weather === 'cloudy' ? 0.7 : (weather === 'rain' ? 0.3 : 1.0);
                data[idx+3] -= heat * 0.07 * simSpeed * dryingMod;
                if(state === S_LIVE && data[idx+3] < 75) { data[idx+2] = S_DRYING; mesh.setColorAt(i, new THREE.Color(0xb8860b)); }
                if(data[idx+3] <= 0) { data[idx+2] = S_BURNING; mesh.setColorAt(i, new THREE.Color(0xff4500)); }
            }
        }
        mesh.instanceMatrix.needsUpdate = true; mesh.instanceColor.needsUpdate = true;
        controls.update(); renderer.render(scene, camera);
    })();
</script>
</body>
</html>
