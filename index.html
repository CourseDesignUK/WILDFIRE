<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Performance Fire Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.8); color: white;
            padding: 15px; border-radius: 8px; pointer-events: none;
            user-select: none;
        }
        .control { margin-bottom: 10px; pointer-events: auto; }
        label { display: inline-block; width: 120px; }
        span { font-weight: bold; color: #ff5500; }
    </style>
</head>
<body>

<div id="ui">
    <h3>Fire Simulation (Spatial Hash)</h3>
    <div class="control">
        <label>Wind Direction:</label>
        <input type="range" id="windDir" min="0" max="360" value="90">
        <span id="windDirVal">90°</span>
    </div>
    <div class="control">
        <label>Wind Speed:</label>
        <input type="range" id="windSpeed" min="0" max="50" value="15">
        <span id="windSpeedVal">15</span>
    </div>
    <div class="control">
        <p>Trees: <span id="treeCount">10000</span> | FPS: <span id="fps">0</span></p>
        <p style="font-size: 0.8em; color: #aaa;">Click anywhere to start a fire.</p>
        <button onclick="resetSim()">Reset Forest</button>
    </div>
</div>

<canvas id="simCanvas"></canvas>

<script>
    // --- CONFIGURATION ---
    const CONFIG = {
        treeCount: 10000,
        treeRadius: 3,
        cellSize: 20, // Grid bucket size
        igniteTemp: 100,
        burnRate: 1.5,
        heatTransfer: 2.0,
        fireDuration: 200 // Frames until burnt out
    };

    const STATES = { NORMAL: 0, HEATING: 1, BURNING: 2, BURNT: 3 };
    const COLORS = ["#2E8B57", "#FFD700", "#FF4500", "#333333"]; // Green, Gold, Red, Dark Grey

    // --- GLOBAL VARIABLES ---
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let width, height;
    
    let trees = [];
    let grid = []; // 2D Spatial Hash
    let cols, rows;
    
    let wind = { x: 0, y: 0 };
    let frameCount = 0;
    let lastTime = performance.now();

    // --- INITIALIZATION ---
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        initGrid();
        initTrees();
    }
    window.addEventListener('resize', resize);

    function initGrid() {
        cols = Math.ceil(width / CONFIG.cellSize);
        rows = Math.ceil(height / CONFIG.cellSize);
        grid = new Array(cols * rows).fill(null).map(() => []);
    }

    function initTrees() {
        trees = new Float32Array(CONFIG.treeCount * 5); // x, y, temp, state, fuel
        // Using flat array for performance (Struct of Arrays layout is faster, but this is simple)
        // [i] = x, [i+1] = y, [i+2] = temp, [i+3] = state, [i+4] = fuel
        
        for (let i = 0; i < CONFIG.treeCount; i++) {
            const idx = i * 5;
            trees[idx] = Math.random() * width;     // x
            trees[idx+1] = Math.random() * height;  // y
            trees[idx+2] = 0;                       // temp
            trees[idx+3] = STATES.NORMAL;           // state
            trees[idx+4] = CONFIG.fireDuration;     // fuel
        }
    }

    // --- SIMULATION CORE ---
    function updateWind() {
        const dir = document.getElementById('windDir').value;
        const speed = document.getElementById('windSpeed').value;
        document.getElementById('windDirVal').innerText = dir + "°";
        document.getElementById('windSpeedVal').innerText = speed;

        const rad = dir * (Math.PI / 180);
        wind.x = Math.cos(rad) * speed;
        wind.y = Math.sin(rad) * speed;
    }

    // Interactive Fire Starter
    canvas.addEventListener('mousedown', (e) => {
        const mx = e.clientX;
        const my = e.clientY;
        // Ignite trees near click
        for (let i = 0; i < CONFIG.treeCount; i++) {
            const idx = i * 5;
            const dx = trees[idx] - mx;
            const dy = trees[idx+1] - my;
            if (dx*dx + dy*dy < 2500) { // 50px radius
                trees[idx+3] = STATES.BURNING;
                trees[idx+2] = CONFIG.igniteTemp + 10;
            }
        }
    });

    // --- MAIN LOOP ---
    function loop() {
        // 1. Clear Grid
        for (let i = 0; i < grid.length; i++) grid[i].length = 0;

        // 2. Populate Grid (Only burning trees matter for heat source)
        for (let i = 0; i < CONFIG.treeCount; i++) {
            const idx = i * 5;
            if (trees[idx+3] === STATES.BURNING) {
                const cx = Math.floor(trees[idx] / CONFIG.cellSize);
                const cy = Math.floor(trees[idx+1] / CONFIG.cellSize);
                if (cx >= 0 && cx < cols && cy >= 0 && cy < rows) {
                    grid[cy * cols + cx].push(idx);
                }
            }
        }

        // 3. Process Trees
        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, width, height);

        // Pre-calculate wind offset for efficiency
        // Wind shifts the heat zone. If wind blows Right (1,0), heat lands to the Right.
        const windShiftX = wind.x * 2.0; 
        const windShiftY = wind.y * 2.0; 
        const reachSq = (CONFIG.cellSize * 1.5) ** 2; // Heat reach squared

        for (let i = 0; i < CONFIG.treeCount; i++) {
            const idx = i * 5;
            let state = trees[idx+3];
            
            // Logic based on state
            if (state === STATES.BURNT) {
                // Do nothing, just draw
                ctx.fillStyle = COLORS[3];
            } 
            else if (state === STATES.BURNING) {
                // Consume fuel
                trees[idx+4] -= CONFIG.burnRate + Math.random();
                if (trees[idx+4] <= 0) trees[idx+3] = STATES.BURNT;
                ctx.fillStyle = COLORS[2];
            } 
            else {
                // NORMAL or HEATING - Check for incoming heat
                const x = trees[idx];
                const y = trees[idx+1];
                const cx = Math.floor(x / CONFIG.cellSize);
                const cy = Math.floor(y / CONFIG.cellSize);

                let heatReceived = 0;

                // Check 3x3 Grid Neighbors
                for (let ny = cy - 1; ny <= cy + 1; ny++) {
                    for (let nx = cx - 1; nx <= cx + 1; nx++) {
                        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                            const cell = grid[ny * cols + nx];
                            for (let j = 0; j < cell.length; j++) {
                                const fireIdx = cell[j];
                                
                                // Vector from Fire to Me
                                const fx = trees[fireIdx];
                                const fy = trees[fireIdx+1];
                                
                                // "Effective" fire position is shifted by wind
                                // (Fire blows its heat 'downwind')
                                const efx = fx + windShiftX;
                                const efy = fy + windShiftY;

                                const distSq = (x - efx)**2 + (y - efy)**2;
                                
                                if (distSq < reachSq) {
                                    heatReceived += CONFIG.heatTransfer;
                                }
                            }
                        }
                    }
                }

                if (heatReceived > 0) {
                    trees[idx+2] += heatReceived;
                    trees[idx+3] = STATES.HEATING;
                    ctx.fillStyle = COLORS[1]; // Heating
                    
                    if (trees[idx+2] > CONFIG.igniteTemp) {
                        trees[idx+3] = STATES.BURNING;
                    }
                } else {
                    // Cooling
                    if (trees[idx+2] > 0) trees[idx+2] -= 0.5;
                    if (trees[idx+2] < 0) trees[idx+2] = 0;
                    
                    if (trees[idx+3] === STATES.HEATING && trees[idx+2] < 10) {
                        trees[idx+3] = STATES.NORMAL;
                    }
                    ctx.fillStyle = state === STATES.HEATING ? COLORS[1] : COLORS[0];
                }
            }

            // Draw Dot
            ctx.beginPath();
            ctx.arc(trees[idx], trees[idx+1], CONFIG.treeRadius, 0, Math.PI*2);
            ctx.fill();
        }

        // FPS Counter
        frameCount++;
        const now = performance.now();
        if (now - lastTime >= 1000) {
            document.getElementById('fps').innerText = frameCount;
            frameCount = 0;
            lastTime = now;
        }

        requestAnimationFrame(loop);
    }

    function resetSim() {
        initTrees();
    }

    // Start
    document.getElementById('windDir').addEventListener('input', updateWind);
    document.getElementById('windSpeed').addEventListener('input', updateWind);
    
    resize();
    updateWind();
    requestAnimationFrame(loop);

</script>
</body>
</html>
