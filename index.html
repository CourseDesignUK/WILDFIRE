<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DFRP Wildfire Simulator v1.5 - Persistent HUD</title>
    <style>
        body { margin: 0; overflow: hidden; background: #eef0f5; font-family: 'Segoe UI', sans-serif; }
        
        /* --- UI STYLES --- */
        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.95); color: #333;
            padding: 15px; border-radius: 8px; border: 1px solid #ccc;
            width: 290px; user-select: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-height: 90vh; overflow-y: auto; z-index: 100;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
        }
        .ui-hidden { transform: translateX(-310px); opacity: 0.5; }

        /* --- UI INDICATOR (Tab) --- */
        #uiIndicator {
            position: absolute; top: 20px; left: 0;
            background: #d32f2f; color: white; padding: 10px 6px;
            border-radius: 0 4px 4px 0; font-size: 10px; font-weight: bold;
            writing-mode: vertical-lr; text-transform: uppercase;
            cursor: pointer; z-index: 90; display: none;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2);
        }
        .ui-hidden + #uiIndicator { display: block; }

        .header-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #ddd; padding-bottom: 8px; margin-bottom: 10px; }
        h3 { margin: 0; color: #222; font-weight: 600; font-size: 16px; }
        #mainHelpBtn { background: #333; color: white; border: none; border-radius: 4px; width: 24px; height: 24px; cursor: pointer; }
        .control { margin-bottom: 15px; }
        label { display: flex; justify-content: space-between; align-items: center; font-size: 11px; color: #666; margin-bottom: 5px; text-transform: uppercase; font-weight: bold; }
        input[type=range] { width: 100%; accent-color: #d32f2f; cursor: pointer; }
        button#resetBtn { background: #f0f0f0; border: 1px solid #ccc; padding: 8px; width: 100%; cursor: pointer; border-radius: 4px; font-size: 11px; font-weight: bold; }
        .val { color: #d32f2f; font-weight: 700; }

        /* --- TOOLBAR (ALWAYS VISIBLE) --- */
        #toolbar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; background: white; padding: 12px 25px;
            border-radius: 50px; box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 100; align-items: center;
        }

        .tool { width: 54px; height: 54px; border-radius: 50%; border: 2px solid #eee; background: white; cursor: pointer; font-size: 24px; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
        .tool:hover { transform: scale(1.1); }
        .tool.active { border-color: #d32f2f; background: #fff0f0; }

        .data-readout { display: flex; flex-direction: column; align-items: center; min-width: 85px; border-left: 1px solid #eee; padding: 0 15px; }
        .data-label { font-size: 9px; text-transform: uppercase; color: #999; font-weight: 800; }
        .data-val { font-size: 16px; font-weight: 700; color: #333; }

        #compass { width: 54px; height: 54px; border-radius: 50%; background: #222; border: 2px solid #444; display: flex; align-items: center; justify-content: center; }
        #compassSvg { width: 100%; height: 100%; }

        #loading { position: absolute; top:0; left:0; width:100%; height:100%; background:#eef0f5; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:2000; }
        
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2100; justify-content: center; align-items: center; backdrop-filter: blur(4px); }
        .modal-content { background: white; padding: 30px; border-radius: 12px; max-width: 500px; position: relative; }
        .close-modal { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

<div id="loading">Generating Environment...</div>

<div id="ui">
    <div class="header-row">
        <h3>DFRP Simulator v1.5</h3>
        <button id="mainHelpBtn">?</button>
    </div>
    <div class="control">
        <label>Simulation Speed <span id="simSpeedVal" class="val">1.0x</span></label>
        <input type="range" id="simSpeed" min="0.1" max="5.0" step="0.1" value="1.0">
    </div>
    <div class="control">
        <label>Wind Heading <span id="windDirVal" class="val">0Â°</span></label>
        <input type="range" id="windDir" min="0" max="360" value="0">
    </div>
    <div class="control">
        <label>Wind Speed <span id="windSpeedVal" class="val">25</span></label>
        <input type="range" id="windSpeed" min="0" max="80" value="25">
    </div>
    <div class="control">
        <label>Fuel Moisture <span id="moistureVal" class="val">15%</span></label>
        <input type="range" id="moisture" min="5" max="30" value="15">
    </div>
    <button id="resetBtn">Regenerate Terrain</button>
</div>

<div id="uiIndicator">Settings</div>

<div id="toolbar">
    <div class="tool" id="toolIgnite">ðŸ”¥</div>
    <div class="tool" id="toolCut">ðŸª“</div>
    <div class="data-readout"><span class="data-label">Time</span><span class="data-val" id="timeDisplay">10:00 AM</span></div>
    <div class="data-readout" style="border-right:1px solid #eee"><span class="data-label">Acres</span><span class="data-val" id="acresDisplay">0.0</span></div>
    <div id="compass"><svg id="compassSvg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="46" fill="#222" stroke="#555" stroke-width="2"/><text x="50" y="24" font-weight="bold" font-size="14" fill="#d32f2f" text-anchor="middle">N</text></svg></div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const CONFIG = { count: 80000, worldSize: 1500, cellSize: 20, baseSpreadRate: 0.05, dryingRate: 0.07, acreConst: 0.012 };
    const S_LIVE = 0, S_DRYING = 1, S_BURNING = 2, S_CHARRED = 3, S_CUT = 4;
    const F_GRASS = 0, F_BRUSH = 1, F_TIMBER = 2;
    const FUEL_PROPS = {
        [F_GRASS]:  { spread: 2.5, burn: 0.4,  scaleY: 0.15, col: 0x7cfc00 }, 
        [F_BRUSH]:  { spread: 1.0, burn: 1.0,  scaleY: 0.6,  col: 0x556b2f }, 
        [F_TIMBER]: { spread: 0.4, burn: 3.5,  scaleY: 2.2,  col: 0x004d00 }  
    };

    let currentTool = null, simSpeed = 1.0, spatialMap = [], acres = 0, simMins = 600;
    const mapDim = Math.ceil(CONFIG.worldSize / CONFIG.cellSize) + 2;
    const mapOffset = CONFIG.worldSize / 2;
    const STRIDE = 8;
    let data = new Float32Array(CONFIG.count * STRIDE);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 1, 10000);
    camera.position.set(-600, 500, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.left = -1000; sun.shadow.camera.right = 1000;
    scene.add(sun);
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemi);

    function getElevation(x, z) { return Math.sin(x*0.005)*30 + Math.cos(z*0.004)*30; }
    function getFuelType(x, z) { const n = Math.sin(x*0.003) + Math.cos(z*0.003); return n > 0.8 ? F_TIMBER : (n < -0.5 ? F_GRASS : F_BRUSH); }

    const groundGeo = new THREE.PlaneGeometry(1800, 1800, 100, 100);
    const gPos = groundGeo.attributes.position;
    for(let i=0; i<gPos.count; i++) gPos.setZ(i, getElevation(gPos.getX(i), -gPos.getY(i)));
    groundGeo.computeVertexNormals();
    const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x556b2f }));
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    const fuelGeo = new THREE.DodecahedronGeometry(2, 0); fuelGeo.translate(0, 1, 0);
    const mesh = new THREE.InstancedMesh(fuelGeo, new THREE.MeshStandardMaterial({ color: 0xffffff }), CONFIG.count);
    mesh.castShadow = true; scene.add(mesh);

    const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,-1), new THREE.Vector3(0,300,0), 100, 0xd32f2f);
    scene.add(arrow);

    const _mat = new THREE.Matrix4(), _vpos = new THREE.Vector3(), _vscale = new THREE.Vector3();
    let windVec = { x: 0, z: -1 }, windSpd = 25, moisture = 15;

    function init() {
        acres = 0; simMins = 600;
        spatialMap = new Array(mapDim*mapDim).fill(0).map(()=>[]);
        for(let i=0; i<CONFIG.count; i++) {
            const idx = i * STRIDE;
            const x = (Math.random()-0.5) * CONFIG.worldSize;
            const z = (Math.random()-0.5) * CONFIG.worldSize;
            const y = getElevation(x, z), type = getFuelType(x, z), props = FUEL_PROPS[type];
            data[idx] = x; data[idx+1] = z; data[idx+2] = S_LIVE; data[idx+3] = moisture * 10;
            data[idx+4] = (2500 * props.burn); data[idx+6] = y; data[idx+7] = type;
            _mat.makeTranslation(x, y, z);
            _vscale.set(1, props.scaleY, 1);
            _mat.scale(_vscale);
            mesh.setMatrixAt(i, _mat); mesh.setColorAt(i, new THREE.Color(props.col));
        }
        mesh.instanceMatrix.needsUpdate = true; mesh.instanceColor.needsUpdate = true;
        document.getElementById('loading').style.display = 'none';
    }

    function updatePhysics() {
        simMins += (0.05 * simSpeed);
        const dayProgress = (simMins % 1440) / 1440;
        const angle = dayProgress * Math.PI * 2 - Math.PI/2;
        sun.position.set(Math.cos(angle)*1000, Math.sin(angle)*1000, 300);
        sun.intensity = Math.max(0, Math.sin(angle)*1.5);
        scene.background = new THREE.Color().setHSL(0.6, 0.4, Math.max(0.05, Math.sin(angle)*0.5 + 0.5));

        const h = Math.floor(simMins/60)%24, m = Math.floor(simMins%60);
        document.getElementById('timeDisplay').textContent = `${h%12||12}:${m<10?'0':''}${m} ${h>=12?'PM':'AM'}`;
        document.getElementById('acresDisplay').textContent = acres.toFixed(1);

        for(let i=0; i<spatialMap.length; i++) spatialMap[i].length = 0;
        for(let i=0; i<CONFIG.count; i++) {
            if(data[i*STRIDE+2] === S_BURNING) {
                const gx = Math.floor((data[i*STRIDE]+mapOffset)/CONFIG.cellSize), gz = Math.floor((data[i*STRIDE+1]+mapOffset)/CONFIG.cellSize);
                if(gx>=0 && gx<mapDim && gz>=0 && gz<mapDim) spatialMap[gz*mapDim+gx].push(i);
            }
        }

        for(let i=0; i<CONFIG.count; i++) {
            const idx = i*STRIDE, state = data[idx+2];
            if(state === S_BURNING) {
                data[idx+4] -= simSpeed;
                if(data[idx+4]<=0) {
                    data[idx+2] = S_CHARRED; acres += CONFIG.acreConst;
                    mesh.setColorAt(i, new THREE.Color(0x111111));
                    mesh.instanceColor.needsUpdate = true;
                }
            } else if(state < S_BURNING) {
                const tx = data[idx], tz = data[idx+1], gx = Math.floor((tx+mapOffset)/CONFIG.cellSize), gz = Math.floor((tz+mapOffset)/CONFIG.cellSize);
                let heat = 0;
                for(let nz=gz-1; nz<=gz+1; nz++) {
                    for(let nx=gx-1; nx<=gx+1; nx++) {
                        if(nx>=0 && nx<mapDim && nz>=0 && nz<mapDim) {
                            spatialMap[nz*mapDim+nx].forEach(fIdx => {
                                const dx = tx-data[fIdx*STRIDE], dz = tz-data[fIdx*STRIDE+1], dSq = dx*dx+dz*dz;
                                if(dSq < 800) {
                                    const d = Math.sqrt(dSq), dot = (dx/d)*windVec.x + (dz/d)*windVec.z;
                                    heat += (1-d/30) * (1+dot*windSpd*0.1) * CONFIG.baseSpreadRate * simSpeed;
                                }
                            });
                        }
                    }
                }
                if(heat > 0) {
                    data[idx+3] -= heat * CONFIG.dryingRate;
                    if(data[idx+3]<=0) {
                        data[idx+2] = S_BURNING; mesh.setColorAt(i, new THREE.Color(0xff4500));
                        mesh.instanceColor.needsUpdate = true;
                    }
                }
            }
        }
    }

    const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    window.addEventListener('mousedown', e => {
        if(e.target.tagName !== 'CANVAS' || !currentTool) return;
        mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(ground);
        if(hits.length > 0) {
            const pt = hits[0].point;
            for(let i=0; i<CONFIG.count; i++) {
                const idx = i*STRIDE;
                if(Math.pow(data[idx]-pt.x, 2) + Math.pow(data[idx+1]-pt.z, 2) < (currentTool==='ignite'?900:150)) {
                    if(currentTool==='ignite') { data[idx+2] = S_BURNING; data[idx+3] = 0; }
                    else { data[idx+2] = S_CUT; _mat.makeScale(0,0,0); mesh.setMatrixAt(i, _mat); mesh.instanceMatrix.needsUpdate=true; }
                }
            }
            mesh.instanceColor.needsUpdate = true;
        }
    });

    document.getElementById('toolIgnite').onclick = function() { currentTool = currentTool==='ignite'?null:'ignite'; this.classList.toggle('active', currentTool==='ignite'); document.getElementById('toolCut').classList.remove('active'); };
    document.getElementById('toolCut').onclick = function() { currentTool = currentTool==='cut'?null:'cut'; this.classList.toggle('active', currentTool==='cut'); document.getElementById('toolIgnite').classList.remove('active'); };
    
    const ui = document.getElementById('ui');
    let uiTimer;
    function showUI() { ui.classList.remove('ui-hidden'); clearTimeout(uiTimer); }
    function hideUI() { uiTimer = setTimeout(() => ui.classList.add('ui-hidden'), 3000); }
    ui.onmouseenter = showUI; ui.onmouseleave = hideUI;
    document.getElementById('uiIndicator').onmouseenter = showUI;
    hideUI();

    document.getElementById('simSpeed').oninput = e => { simSpeed = parseFloat(e.target.value); document.getElementById('simSpeedVal').textContent = simSpeed.toFixed(1)+'x'; };
    document.getElementById('windDir').oninput = e => { 
        const d = e.target.value; document.getElementById('windDirVal').textContent = d+'Â°';
        const r = d * Math.PI/180; windVec.x = Math.sin(r); windVec.z = -Math.cos(r);
        arrow.setDirection(new THREE.Vector3(windVec.x, 0, windVec.z));
    };
    document.getElementById('resetBtn').onclick = () => init();

    init();
    function animate() { requestAnimationFrame(animate); updatePhysics(); controls.update(); document.getElementById('compassSvg').style.transform = `rotate(${controls.getAzimuthalAngle()}rad)`; renderer.render(scene, camera); }
    animate();
</script>
</body>
</html>
