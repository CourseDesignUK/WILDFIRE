<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DFRP Wildfire Simulator v1.5 - Chinook Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #eef0f5; font-family: 'Segoe UI', sans-serif; }
        
        /* --- UI STYLES --- */
        #splashScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .splash-content { text-align: center; color: white; animation: fadeIn 1.5s ease-out; }
        .splash-content h1 { font-size: 3.5rem; margin-bottom: 10px; letter-spacing: 2px; }
        #startAppBtn {
            padding: 15px 50px; font-size: 18px; font-weight: bold; text-transform: uppercase;
            background: #d32f2f; color: white; border: none; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 20px rgba(211, 47, 47, 0.6);
            transition: 0.2s;
        }
        #startAppBtn:hover { transform: scale(1.05); background: #b71c1c; }

        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.95); color: #333;
            padding: 15px; border-radius: 8px; width: 290px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 10; transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .ui-hidden { transform: translateX(-320px); opacity: 0; }

        .control { margin-bottom: 12px; }
        label { display: flex; justify-content: space-between; font-size: 11px; color: #666; font-weight: bold; text-transform: uppercase; }
        input[type=range] { width: 100%; accent-color: #d32f2f; cursor: pointer; }
        .val { color: #d32f2f; font-weight: 700; }

        #toolbar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; background: white; padding: 10px 20px;
            border-radius: 50px; box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 100; align-items: center;
        }
        .tool {
            width: 50px; height: 50px; border-radius: 50%; border: 2px solid #eee;
            background: white; cursor: pointer; font-size: 22px; display: flex;
            align-items: center; justify-content: center; transition: 0.2s;
        }
        .tool.active { border-color: #d32f2f; background: #fff0f0; transform: scale(1.1); }
        
        .data-readout { border-left: 1px solid #eee; padding: 0 15px; text-align: center; }
        .data-label { font-size: 9px; color: #999; font-weight: 800; display: block; }
        .data-val { font-size: 15px; font-weight: 700; color: #333; }

        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #eef0f5; display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 20px; color: #555; z-index: 999;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

<div id="splashScreen">
    <div class="splash-content">
        <h1>DFRP WILDFIRE SIM</h1>
        <p>GPGPU Physics & Aerial Suppression Update</p>
        <button id="startAppBtn">Enter Simulation</button>
    </div>
</div>

<div id="loading">Generating Environment...</div>

<div id="ui">
    <h3 style="margin:0 0 10px 0; font-size:16px;">System Parameters</h3>
    <div class="control">
        <label>Sim Speed <span id="simSpeedVal" class="val">1.0x</span></label>
        <input type="range" id="simSpeed" min="0.1" max="5.0" step="0.1" value="1.0">
    </div>
    <div class="control">
        <label>Wind Heading <span id="windDirVal" class="val">0¬∞</span></label>
        <input type="range" id="windDir" min="0" max="360" value="0">
    </div>
    <div class="control">
        <label>Wind Speed <span id="windSpeedVal" class="val">25</span></label>
        <input type="range" id="windSpeed" min="0" max="80" value="25">
    </div>
    <div class="control">
        <label>Base Moisture <span id="moistureVal" class="val">15%</span></label>
        <input type="range" id="moisture" min="5" max="30" value="15">
    </div>
    <button id="resetBtn" style="width:100%; padding:8px; cursor:pointer;">Regenerate Terrain</button>
</div>

<div id="toolbar">
    <div class="tool" id="toolIgnite" title="Ignite Fire">üî•</div>
    <div class="tool" id="toolCut" title="Firebreak">ü™ì</div>
    <div class="tool" id="toolWater" title="Chinook Drop">üöÅ</div>
    
    <div class="data-readout">
        <span class="data-label">Time</span>
        <span class="data-val" id="timeDisplay">10:00 AM</span>
    </div>
    <div class="data-readout">
        <span class="data-label">Acres</span>
        <span class="data-val" id="acresDisplay">0.0</span>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const CONFIG = {
        count: 80000, worldSize: 1500, cellSize: 25,
        baseSpreadRate: 0.05, dryingRate: 0.08,
        acreageConstant: 0.012 
    };

    const S_LIVE = 0, S_DRYING = 1, S_BURNING = 2, S_CHARRED = 3, S_CUT = 4;
    const F_GRASS = 0, F_BRUSH = 1, F_TIMBER = 2;

    const FUEL_PROPS = {
        [F_GRASS]:  { spread: 2.5, burn: 0.4,  scaleY: 0.15, col: 0x9acd32 }, 
        [F_BRUSH]:  { spread: 1.0, burn: 1.0,  scaleY: 0.6,  col: 0x556b2f }, 
        [F_TIMBER]: { spread: 0.4, burn: 3.5,  scaleY: 2.5,  col: 0x004d00 }  
    };

    // Simulation Data
    let currentTool = null;
    let simSpeedMultiplier = 1.0;
    let spatialMap = [];
    let acresBurned = 0;
    let simMinutes = 600; 
    const mapDim = Math.ceil(CONFIG.worldSize / CONFIG.cellSize) + 2;
    const mapOffset = CONFIG.worldSize / 2;
    const STRIDE = 8;
    let data = new Float32Array(CONFIG.count * STRIDE);

    // Chinook State
    const heliState = {
        active: false,
        phase: 'idle', // idle, approach, dropping, returning
        target: new THREE.Vector3(),
        dropTimer: 0
    };

    // Environment helpers
    const getElevation = (x, z) => Math.sin(x*0.005)*30 + Math.cos(z*0.004)*30 + Math.sin(x*0.01 + z*0.01)*15;
    const isRiver = (x, z) => Math.abs(x - (Math.sin(z * 0.003) * 80 - 300)) < 25;
    const getFuelType = (x, z) => {
        const n = Math.sin(x*0.003) + Math.cos(z*0.003); 
        return n > 0.8 ? F_TIMBER : (n < -0.5 ? F_GRASS : F_BRUSH);
    };

    // Setup Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 1, 10000);
    camera.position.set(-800, 600, 1000);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.maxPolarAngle = Math.PI / 2.1;

    // Lighting
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.castShadow = true;
    sun.shadow.mapSize.set(1024, 1024);
    sun.shadow.camera.left = -800; sun.shadow.camera.right = 800;
    sun.shadow.camera.top = 800; sun.shadow.camera.bottom = -800;
    scene.add(sun);
    const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(ambient);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(2000, 2000, 100, 100);
    const gPos = groundGeo.attributes.position;
    for(let i=0; i<gPos.count; i++) {
        gPos.setZ(i, getElevation(gPos.getX(i), -gPos.getY(i)));
    }
    groundGeo.computeVertexNormals();
    const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x3d4d3d, roughness: 0.8 }));
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Fuel Instancing
    const mesh = new THREE.InstancedMesh(new THREE.DodecahedronGeometry(2,0).translate(0, 1, 0), new THREE.MeshStandardMaterial({ flatShading: true }), CONFIG.count);
    mesh.castShadow = true;
    scene.add(mesh);

    // Chinook Model Creation
    const chinook = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(8, 7, 30), new THREE.MeshStandardMaterial({color: 0x445544}));
    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(6, 5, 6), new THREE.MeshStandardMaterial({color: 0x111111}));
    cockpit.position.z = 16;
    chinook.add(body, cockpit);

    const r1 = new THREE.Mesh(new THREE.BoxGeometry(45, 0.2, 2), new THREE.MeshStandardMaterial({color: 0x111111}));
    const r2 = r1.clone();
    r1.position.set(0, 5, 12); r2.position.set(0, 5, -12);
    chinook.add(r1, r2);
    chinook.position.set(-1500, 400, -1500); // Start off-screen
    scene.add(chinook);

    // Suppression Particles
    const waterPart = new THREE.Points(
        new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(300), 3)),
        new THREE.PointsMaterial({color: 0x4da6ff, size: 4, transparent: true, opacity: 0.7})
    );
    waterPart.visible = false;
    scene.add(waterPart);

    let windVec = { x: 0, z: -1 }, windSpeed = 25, baseMoisture = 15;
    const _mat = new THREE.Matrix4(), _vpos = new THREE.Vector3(), _vscale = new THREE.Vector3(), _vquat = new THREE.Quaternion();

    function initSim() {
        document.getElementById('loading').style.display = 'flex';
        acresBurned = 0;
        spatialMap = new Array(mapDim*mapDim).fill(0).map(()=>[]);

        for(let i=0; i<CONFIG.count; i++) {
            const idx = i * STRIDE;
            const x = (Math.random()-0.5) * CONFIG.worldSize;
            const z = (Math.random()-0.5) * CONFIG.worldSize;
            const y = getElevation(x, z), type = getFuelType(x, z);
            
            data[idx] = x; data[idx+1] = z; data[idx+2] = S_LIVE; data[idx+3] = baseMoisture * 10;
            data[idx+4] = (2000 * FUEL_PROPS[type].burn) * (0.8 + Math.random()*0.4); 
            data[idx+6] = y; data[idx+7] = type;

            if (isRiver(x,z)) { data[idx+2] = S_CUT; _mat.makeScale(0,0,0); }
            else {
                _vpos.set(x, y, z);
                _vscale.set(1.2, FUEL_PROPS[type].scaleY, 1.2);
                _mat.compose(_vpos, new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.random()*6), _vscale);
                mesh.setColorAt(i, new THREE.Color(FUEL_PROPS[type].col));
            }
            mesh.setMatrixAt(i, _mat);
        }
        mesh.instanceMatrix.needsUpdate = true;
        mesh.instanceColor.needsUpdate = true;
        document.getElementById('loading').style.display = 'none';
    }

    function runSuppression() {
        r1.rotation.y += 0.7; r2.rotation.y += 0.7;
        const home = new THREE.Vector3(-1500, 400, -1500);

        if (heliState.phase === 'approach') {
            chinook.lookAt(heliState.target);
            chinook.position.lerp(heliState.target, 0.02);
            if (chinook.position.distanceTo(heliState.target) < 20) {
                heliState.phase = 'dropping';
                heliState.dropTimer = 120;
                waterPart.visible = true;
            }
        } else if (heliState.phase === 'dropping') {
            heliState.dropTimer--;
            // Suppression logic: hit fuel near heli
            for(let i=0; i<CONFIG.count; i++) {
                const idx = i*STRIDE;
                const d2 = Math.pow(data[idx]-chinook.position.x, 2) + Math.pow(data[idx+1]-chinook.position.z, 2);
                if (d2 < 2500) {
                    data[idx+3] += 8.0; // Rapidly cool down
                    if (data[idx+3] > 60 && (data[idx+2] === S_BURNING || data[idx+2] === S_DRYING)) {
                        data[idx+2] = S_LIVE;
                        mesh.setColorAt(i, new THREE.Color(FUEL_PROPS[data[idx+7]].col));
                        mesh.instanceColor.needsUpdate = true;
                    }
                }
            }
            // Particle effect
            const p = waterPart.geometry.attributes.position;
            for(let i=0; i<100; i++) {
                p.setXYZ(i, chinook.position.x + (Math.random()-0.5)*30, chinook.position.y - (Math.random()*200), chinook.position.z + (Math.random()-0.5)*30);
            }
            p.needsUpdate = true;
            if (heliState.dropTimer <= 0) { heliState.phase = 'returning'; waterPart.visible = false; }
        } else if (heliState.phase === 'returning') {
            chinook.lookAt(home);
            chinook.position.lerp(home, 0.015);
            if (chinook.position.distanceTo(home) < 50) heliState.phase = 'idle';
        }
    }

    function updateSim() {
        simMinutes += (0.05 * simSpeedMultiplier);
        runSuppression();

        // Skybox / Day Cycle
        const dayP = (simMinutes % 1440) / 1440;
        const angle = dayP * Math.PI * 2 - Math.PI/2;
        sun.position.set(Math.cos(angle)*1000, Math.sin(angle)*1000, 300);
        const skyH = Math.sin(angle);
        const skyC = new THREE.Color();
        if(skyH > 0.1) skyC.setHex(0x87ceeb); else if(skyH > -0.2) skyC.setHSL(0.02, 0.8, 0.6); else skyC.setHex(0x1a1a2e);
        scene.background = skyC;

        // Spread Logic
        for(let i=0; i<spatialMap.length; i++) spatialMap[i].length = 0;
        let activeFires = 0;
        for(let i=0; i<CONFIG.count; i++) {
            if(data[i*STRIDE+2] === S_BURNING) {
                activeFires++;
                const gx = Math.floor((data[i*STRIDE]+mapOffset)/CONFIG.cellSize);
                const gz = Math.floor((data[i*STRIDE+1]+mapOffset)/CONFIG.cellSize);
                if(gx>=0 && gx<mapDim && gz>=0 && gz<mapDim) spatialMap[gz*mapDim+gx].push(i);
            }
        }

        let needColor = false, needMatrix = false;
        for(let i=0; i<CONFIG.count; i++) {
            const idx = i*STRIDE, state = data[idx+2];
            if(state === S_CHARRED || state === S_CUT) continue;

            if(state === S_BURNING) {
                data[idx+4] -= 1.0 * simSpeedMultiplier;
                if(data[idx+4] <= 0) {
                    data[idx+2] = S_CHARRED; acresBurned += CONFIG.acreageConstant;
                    mesh.setColorAt(i, new THREE.Color(0x111111));
                    _vpos.set(data[idx], data[idx+6], data[idx+1]);
                    _mat.compose(_vpos, new THREE.Quaternion(), new THREE.Vector3(1,0.05,1));
                    mesh.setMatrixAt(i, _mat); needColor = needMatrix = true;
                } else if(Math.random() > 0.9) {
                    mesh.setColorAt(i, new THREE.Color(0xff4500).lerp(new THREE.Color(0xffff00), Math.random()));
                    needColor = true;
                }
            } else {
                // Heat detection
                const gx = Math.floor((data[idx]+mapOffset)/CONFIG.cellSize), gz = Math.floor((data[idx+1]+mapOffset)/CONFIG.cellSize);
                let heat = 0;
                for(let nz=gz-1; nz<=gz+1; nz++) {
                    for(let nx=gx-1; nx<=gx+1; nx++) {
                        if(nx>=0 && nx<mapDim && nz>=0 && nz<mapDim) {
                            spatialMap[nz*mapDim+nx].forEach(fIdx => {
                                const f = fIdx*STRIDE;
                                const dx = data[idx]-data[f], dz = data[idx+1]-data[f+1], dy = data[idx+6]-data[f+6];
                                const d2 = dx*dx + dz*dz;
                                if(d2 < 1200) {
                                    const d = Math.sqrt(d2), dot = (dx/d)*windVec.x + (dz/d)*windVec.z;
                                    const wB = dot > 0 ? 1 + (dot*windSpeed*0.12) : 0.5;
                                    const sB = dy > 0 ? 1 + (dy/d)*5 : 1;
                                    heat += (1 - d/35) * wB * sB * FUEL_PROPS[data[idx+7]].spread * CONFIG.baseSpreadRate * simSpeedMultiplier;
                                }
                            });
                        }
                    }
                }
                if(heat > 0) {
                    data[idx+3] -= heat * CONFIG.dryingRate;
                    if(state === S_LIVE && data[idx+3] < baseMoisture*5) { data[idx+2] = S_DRYING; mesh.setColorAt(i, new THREE.Color(0xb8860b)); needColor = true; }
                    if(data[idx+3] <= 0) { data[idx+2] = S_BURNING; mesh.setColorAt(i, new THREE.Color(0xff4500)); needColor = true; }
                }
            }
        }
        if(needColor) mesh.instanceColor.needsUpdate = true;
        if(needMatrix) mesh.instanceMatrix.needsUpdate = true;
        
        // Update Displays
        const h = Math.floor(simMinutes/60)%24;
        document.getElementById('timeDisplay').textContent = `${h%12||12}:${(simMinutes%60).toFixed(0).padStart(2,'0')} ${h>=12?'PM':'AM'}`;
        document.getElementById('acresDisplay').textContent = acresBurned.toFixed(1);
    }

    // Input Handling
    const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    window.addEventListener('mousedown', e => {
        if(e.target.tagName !== 'CANVAS') return;
        mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse, camera);
        const hit = raycaster.intersectObject(ground);
        if(hit.length > 0) {
            const p = hit[0].point;
            if (currentTool === 'water' && heliState.phase === 'idle') {
                heliState.target.set(p.x, 200, p.z); heliState.phase = 'approach';
            } else if (currentTool === 'ignite') {
                for(let i=0; i<CONFIG.count; i++) {
                    const idx = i*STRIDE;
                    if(Math.pow(data[idx]-p.x, 2) + Math.pow(data[idx+1]-p.z, 2) < 400) { data[idx+2] = S_BURNING; data[idx+3] = 0; }
                }
            } else if (currentTool === 'cut') {
                for(let i=0; i<CONFIG.count; i++) {
                    const idx = i*STRIDE;
                    if(Math.pow(data[idx]-p.x, 2) + Math.pow(data[idx+1]-p.z, 2) < 200) { data[idx+2] = S_CUT; _mat.makeScale(0,0,0); mesh.setMatrixAt(i, _mat); }
                }
                mesh.instanceMatrix.needsUpdate = true;
            }
        }
    });

    // UI Listeners
    document.getElementById('startAppBtn').onclick = () => document.getElementById('splashScreen').style.opacity = 0;
    document.getElementById('toolIgnite').onclick = function() { currentTool = 'ignite'; updateTools(this); };
    document.getElementById('toolCut').onclick = function() { currentTool = 'cut'; updateTools(this); };
    document.getElementById('toolWater').onclick = function() { currentTool = 'water'; updateTools(this); };
    
    function updateTools(el) {
        document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
        el.classList.add('active');
    }

    const updateControls = () => {
        const d = document.getElementById('windDir').value, s = document.getElementById('windSpeed').value, m = document.getElementById('moisture').value;
        simSpeedMultiplier = document.getElementById('simSpeed').value;
        document.getElementById('windDirVal').textContent = d + '¬∞';
        document.getElementById('windSpeedVal').textContent = s;
        document.getElementById('moistureVal').textContent = m + '%';
        document.getElementById('simSpeedVal').textContent = parseFloat(simSpeedMultiplier).toFixed(1) + 'x';
        windVec.x = Math.sin(d*(Math.PI/180)); windVec.z = -Math.cos(d*(Math.PI/180));
        windSpeed = s; baseMoisture = m;
    };

    document.querySelectorAll('input').forEach(i => i.oninput = updateControls);
    document.getElementById('resetBtn').onclick = initSim;
    window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };

    initSim(); updateControls();
    function animate() { requestAnimationFrame(animate); updateSim(); controls.update(); renderer.render(scene, camera); }
    animate();
</script>
</body>
</html>
